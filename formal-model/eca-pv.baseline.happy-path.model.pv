(* ECA Protocol - ProVerif Model v3 - BASELINE
  This version implements mutual authentication and is formally proven
  to satisfy the security properties of authentication, freshness,
  key binding, and confidentiality with exposure-tolerant (public) BootFactor.
  
  Updated to align with specification:
  - Phase 2 encrypts (VF, nonce) tuple as specified
  - Includes eca_uuid in all key derivations for session uniqueness
*)

(* --- Types --- *)
type BootFactor.
type InstanceFactor.
type VFSeed.
type ValidatorFactor.
type IdentityKey.
type PublicKey.
type EncPrivateKey.
type EncPublicKey.
type IHB.
type JP_Proof.
type Signature.
type Nonce.
type MAC.
type BoundHash.
type PoPTag.
type HmacKey.
type UUID.

(* --- Constants and Channels --- *)
free public_channel: channel.
free bootFactor: BootFactor. (* BF is public, as intended *)

(* --- Cryptographic Primitives --- *)

(* Key Derivations with eca_uuid *)
fun deriveIdKey(BootFactor, ValidatorFactor, UUID): IdentityKey.
fun derivePubKey(IdentityKey): PublicKey.
fun deriveEncKey(BootFactor, InstanceFactor, UUID): EncPrivateKey [private].
fun deriveEncPubKey(EncPrivateKey): EncPublicKey.
fun deriveHmacKey(BootFactor, ValidatorFactor, UUID): HmacKey.

(* MAC for initial proof *)
fun deriveAuthKey(BootFactor, InstanceFactor, UUID): bitstring.
fun computeMAC(bitstring, bitstring): MAC.
reduc forall m: bitstring, k: bitstring; verifyMAC(m, computeMAC(m, k), k) = true.

(* Protocol-specific calculations *)
fun calculateIHB(BootFactor, InstanceFactor): IHB.
fun calculateJP(BootFactor, ValidatorFactor): JP_Proof.
fun calculateBoundHash(IHB, PublicKey, Nonce): BoundHash.
fun computePoP(HmacKey, BoundHash): PoPTag.
reduc forall k: HmacKey, h: BoundHash; verifyPoP(computePoP(k, h), k, h) = true.

(* Standard Signatures *)
fun sign(bitstring, IdentityKey): Signature.
reduc forall m: bitstring, ik: IdentityKey; verify(m, sign(m, ik), derivePubKey(ik)) = m.

(* Encryption for tuple (VF, Nonce) *)
fun penc(bitstring, EncPublicKey): bitstring.
reduc forall m: bitstring, ek: EncPrivateKey; pdec(penc(m, deriveEncPubKey(ek)), ek) = m.

fun mkVF(VFSeed, InstanceFactor): ValidatorFactor [private].

(* --- Events for Core Properties --- *)
event AttesterInitiates(BootFactor, InstanceFactor, UUID).
event VerifierAccepts(BootFactor, InstanceFactor, UUID).
event VFReleased(ValidatorFactor).
event VerifierGeneratesNonce(Nonce).
event AttesterUsesNonce(Nonce).
event AttesterPresentsKey(PublicKey).
event VerifierValidatesWithKey(PublicKey).


(* --- New Events for KCI Test --- *)
event AttesterAuthenticatesVerifier(PublicKey).
event VerifierAuthenticated(IdentityKey).
event VerifierKeyMatch(PublicKey, IdentityKey).

(* --- Standard Protocol Processes --- *)

let AttesterProcess(bf: BootFactor, ifa: InstanceFactor, uuid: UUID, verifierPubKey: PublicKey) =
    (* Phase 1: Prove possession of bf using the instance factor *)
    let authKey = deriveAuthKey(bf, ifa, uuid) in
    let encKey = deriveEncKey(bf, ifa, uuid) in
    let encPubKey = deriveEncPubKey(encKey) in
    let ihb = calculateIHB(bf, ifa) in
    event AttesterInitiates(bf, ifa, uuid);
    let phase1_payload = (encPubKey, ihb) in
    let phase1_mac = computeMAC(phase1_payload, authKey) in
    out(public_channel, (phase1_payload, phase1_mac));

    (* Phase 2: Receive the encrypted (VF, nonce) tuple *)
    in(public_channel, (ciphertext: bitstring, verifier_sig: Signature));
    let verified_ciphertext = verify(ciphertext, verifier_sig, verifierPubKey) in
    let plaintext = pdec(verified_ciphertext, encKey) in
    let (vf: ValidatorFactor, nonce: Nonce) = plaintext in
    event AttesterUsesNonce(nonce);

    (* Phase 3: Final proof using BOTH bf and vf *)
    let idKey = deriveIdKey(bf, vf, uuid) in
    let pubKey = derivePubKey(idKey) in
    event AttesterPresentsKey(pubKey);
    let jp_proof = calculateJP(bf, vf) in
    let hmacKey = deriveHmacKey(bf, vf, uuid) in
    let bound_hash = calculateBoundHash(ihb, pubKey, nonce) in
    let pop_tag = computePoP(hmacKey, bound_hash) in
    let final_eat_payload = (ihb, jp_proof, nonce, pubKey, pop_tag) in
    let final_signature = sign(final_eat_payload, idKey) in
    out(public_channel, (final_eat_payload, final_signature, pubKey)).

(* Modified Attester that tracks Verifier authentication for KCI test *)
let AttesterProcessWithAuth(bf: BootFactor, ifa: InstanceFactor, uuid: UUID, verifierPubKey: PublicKey) =
    (* Phase 1: Same as standard *)
    let authKey = deriveAuthKey(bf, ifa, uuid) in
    let encKey = deriveEncKey(bf, ifa, uuid) in
    let encPubKey = deriveEncPubKey(encKey) in
    let ihb = calculateIHB(bf, ifa) in
    event AttesterInitiates(bf, ifa, uuid);
    let phase1_payload = (encPubKey, ihb) in
    let phase1_mac = computeMAC(phase1_payload, authKey) in
    out(public_channel, (phase1_payload, phase1_mac));

    (* Phase 2: With authentication tracking *)
    in(public_channel, (ciphertext: bitstring, verifier_sig: Signature));
    let verified_ciphertext = verify(ciphertext, verifier_sig, verifierPubKey) in

    (* The code below only runs if the signature is valid. *)
    (* This is the correct way to handle the check. *)
    event AttesterAuthenticatesVerifier(verifierPubKey);
    let plaintext = pdec(verified_ciphertext, encKey) in
    let (vf: ValidatorFactor, nonce: Nonce) = plaintext in
    event AttesterUsesNonce(nonce);

    (* Phase 3: Same as standard *)
    let idKey = deriveIdKey(bf, vf, uuid) in
    let pubKey = derivePubKey(idKey) in
    event AttesterPresentsKey(pubKey);
    let jp_proof = calculateJP(bf, vf) in
    let hmacKey = deriveHmacKey(bf, vf, uuid) in
    let bound_hash = calculateBoundHash(ihb, pubKey, nonce) in
    let pop_tag = computePoP(hmacKey, bound_hash) in
    let final_eat_payload = (ihb, jp_proof, nonce, pubKey, pop_tag) in
    let final_signature = sign(final_eat_payload, idKey) in
    out(public_channel, (final_eat_payload, final_signature, pubKey)).

let VerifierProcess(expected_bf: BootFactor, expected_ifa: InstanceFactor,
                    uuid: UUID, verifierIdKey: IdentityKey) =
    (* Phase 1: Verify Attester's proof of possession *)
    in(public_channel, (phase1_payload: bitstring, phase1_mac: MAC));
    let (attester_enc_pk: EncPublicKey, received_ihb: IHB) = phase1_payload in
    let expected_authKey = deriveAuthKey(expected_bf, expected_ifa, uuid) in

    if verifyMAC(phase1_payload, phase1_mac, expected_authKey) then
        let expected_ihb = calculateIHB(expected_bf, expected_ifa) in
        if received_ihb = expected_ihb then
            let expected_encKey = deriveEncKey(expected_bf, expected_ifa, uuid) in
            let expected_encPubKey = deriveEncPubKey(expected_encKey) in
            if attester_enc_pk = expected_encPubKey then
                (* Phase 2: Create and encrypt (VF, nonce) tuple *)
                new seed: VFSeed;
                let vf = mkVF(seed, expected_ifa) in
                event VFReleased(vf);
                new nonce: Nonce;
                event VerifierGeneratesNonce(nonce);
                let plaintext = (vf, nonce) in
                let ciphertext = penc(plaintext, attester_enc_pk) in
                let verifier_signature = sign(ciphertext, verifierIdKey) in
                event VerifierAuthenticated(verifierIdKey);
                (* Add this line to assert the key relationship *)
                event VerifierKeyMatch(derivePubKey(verifierIdKey), verifierIdKey);
                out(public_channel, (ciphertext, verifier_signature));

                (* Phase 3: Verify the final proof of joint possession *)
                in(public_channel, (final_eat_payload: bitstring, final_signature: Signature, final_pubKey: PublicKey));
                let verified_final = verify(final_eat_payload, final_signature, final_pubKey) in
                let (rec_ihb: IHB, rec_jp: JP_Proof, rec_nonce: Nonce, rec_pubKey: PublicKey, rec_pop: PoPTag) = verified_final in
                if rec_nonce = nonce then
                    let expected_idKey = deriveIdKey(expected_bf, vf, uuid) in
                    let expected_pubKey = derivePubKey(expected_idKey) in
                    if final_pubKey = expected_pubKey then
                        event VerifierValidatesWithKey(final_pubKey);
                        let expected_jp = calculateJP(expected_bf, vf) in
                        if rec_jp = expected_jp then
                            let expected_hmac_key = deriveHmacKey(expected_bf, vf, uuid) in
                            let expected_bound_hash = calculateBoundHash(rec_ihb, rec_pubKey, rec_nonce) in
                            if verifyPoP(rec_pop, expected_hmac_key, expected_bound_hash) then
                                event VerifierAccepts(expected_bf, expected_ifa, uuid); 0
                            else 0
                        else 0
                    else 0
                else 0
            else 0
        else 0
    else 0.

(* --- Sanity Check: BF should be public, so this should be true --- *)
query attacker(bootFactor).

(* --- Sanity Check: The function to derive keys should be known --- *)
query bf: BootFactor, vf: ValidatorFactor, uuid: UUID;
      attacker(deriveIdKey(bf, vf, uuid)).

(* --- Core Security Queries --- *)
query bf: BootFactor, ifa: InstanceFactor, uuid: UUID;
      inj-event(VerifierAccepts(bf, ifa, uuid)) ==> inj-event(AttesterInitiates(bf, ifa, uuid)).
query n: Nonce;
      event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)).
query pk: PublicKey;
      event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk)).
query vf: ValidatorFactor;
      event(VFReleased(vf)) && attacker(vf).

(* --- KCI Security Query --- *)
(* Tests if attacker with compromised IF can impersonate Verifier *)
query pk: PublicKey, vk: IdentityKey;
      event(AttesterAuthenticatesVerifier(pk)) &&
      event(VerifierKeyMatch(pk, vk)).
(*
  Expected result: The KCI Security query for a successful run should be reachable 
  (i.e., logically evaluate to TRUE), proving that the KCI attack is not possible.
  ProVerif will report this as "RESULT not (...) is false."
*)

(* --- Main Process --- *)
process
    (* Standard protocol run for baseline *)
    new instanceFactor: InstanceFactor;
    new ecaUuid: UUID;
    new verifierIdKey: IdentityKey;
    (
        AttesterProcess(bootFactor, instanceFactor, ecaUuid, derivePubKey(verifierIdKey))
        |
        VerifierProcess(bootFactor, instanceFactor, ecaUuid, verifierIdKey)
    )
    |
    (* KCI Test Scenario *)
    (
        (* Attacker model: Leak a compromised Instance Factor to the public channel *)
        new compromisedIF: InstanceFactor;
        out(public_channel, compromisedIF)
    )
    |
    (
        (* Honest session under test: Run a full protocol instance using the *)
        (* special AttesterProcessWithAuth to check the KCI property. This session *)
        (* runs in a context where the attacker knows 'compromisedIF'. *)
        new honestIF: InstanceFactor;
        new testUuid: UUID;
        new testVerifierKey: IdentityKey;
        (
            AttesterProcessWithAuth(bootFactor, honestIF, testUuid, derivePubKey(testVerifierKey))
            |
            VerifierProcess(bootFactor, honestIF, testUuid, testVerifierKey)
        )
    )
    
(*
All Expected Results:

Query not attacker(bootFactor[]) is false.
Query not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) is false.

Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) is true.
Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.
Query event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk)) is true.
Query not (event(VFReleased(vf_4)) && attacker(vf_4)) is true.

Query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) is false.

---

Changes in v3:
- Updated to include Key Compromise Impersonation (KCI) test
  - Tests whether compromising an Instance Factor allows impersonating the Verifier

Changes in v2:
- Added UUID type and ecaUuid parameter throughout
- All key derivation functions now include UUID for session uniqueness
- Phase 2 now encrypts the tuple (VF, nonce) as specified, not just VF
- Events updated to include UUID for tracking per-ceremony uniqueness

Author's Address:
  Nathanael Ritz
  Independent
  nathanritz@gmail.com
*)
