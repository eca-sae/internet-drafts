Process 0 (that is, the initial process):
{1}new instanceFactor: InstanceFactor;
{2}new ecaUuid: UUID;
{3}new verifierIdKey: IdentityKey;
(
    {4}let bf: BootFactor = bootFactor in
    {5}let ifa: InstanceFactor = instanceFactor in
    {6}let uuid: UUID = ecaUuid in
    {7}let verifierPubKey: PublicKey = derivePubKey(verifierIdKey) in
    {8}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {9}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {10}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {11}let ihb: IHB = calculateIHB(bf,ifa) in
    {12}event AttesterInitiates(bf,ifa,uuid);
    {13}let phase1_payload: bitstring = (encPubKey,ihb) in
    {14}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {15}out(public_channel, (phase1_payload,phase1_mac));
    {16}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {17}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,verifierPubKey) in
    {18}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {19}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {20}event AttesterUsesNonce(nonce);
    {21}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {22}let pubKey: PublicKey = derivePubKey(idKey) in
    {23}event AttesterPresentsKey(pubKey);
    {24}let jp_proof: JP_Proof = calculateJP(bf,vf) in
    {25}let hmacKey: HmacKey = deriveHmacKey(bf,vf,uuid) in
    {26}let bound_hash: BoundHash = calculateBoundHash(ihb,pubKey,nonce) in
    {27}let pop_tag: PoPTag = computePoP(hmacKey,bound_hash) in
    {28}let final_eat_payload: bitstring = (ihb,jp_proof,nonce,pubKey,pop_tag) in
    {29}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {30}out(public_channel, (final_eat_payload,final_signature,pubKey))
) | (
    {31}let expected_bf: BootFactor = bootFactor in
    {32}let expected_ifa: InstanceFactor = instanceFactor in
    {33}let uuid_1: UUID = ecaUuid in
    {34}let verifierIdKey_1: IdentityKey = verifierIdKey in
    {35}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {36}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {37}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa,uuid_1) in
    {38}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {39}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa) in
    {40}if (received_ihb = expected_ihb) then
    {41}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa,uuid_1) in
    {42}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {43}if (attester_enc_pk = expected_encPubKey) then
    {44}new seed: VFSeed;
    {45}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa) in
    {46}event VFReleased(vf_1);
    {47}new nonce_1: Nonce;
    {48}event VerifierGeneratesNonce(nonce_1);
    {49}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {50}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {51}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey_1) in
    {52}event VerifierAuthenticated(verifierIdKey_1);
    {53}event VerifierKeyMatch(derivePubKey(verifierIdKey_1),verifierIdKey_1);
    {54}out(public_channel, (ciphertext_1,verifier_signature));
    {55}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {56}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {57}let (rec_ihb: IHB,rec_jp: JP_Proof,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_pop: PoPTag) = verified_final in
    {58}if (rec_nonce = nonce_1) then
    {59}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {60}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {61}if (final_pubKey = expected_pubKey) then
    {62}event VerifierValidatesWithKey(final_pubKey);
    {63}let expected_jp: JP_Proof = calculateJP(expected_bf,vf_1) in
    {64}if (rec_jp = expected_jp) then
    {65}let expected_hmac_key: HmacKey = deriveHmacKey(expected_bf,vf_1,uuid_1) in
    {66}let expected_bound_hash: BoundHash = calculateBoundHash(rec_ihb,rec_pubKey,rec_nonce) in
    {67}if verifyPoP(rec_pop,expected_hmac_key,expected_bound_hash) then
    {68}event VerifierAccepts(expected_bf,expected_ifa,uuid_1)
) | (
    {69}new compromisedIF: InstanceFactor;
    {70}out(public_channel, compromisedIF)
) | (
    {71}new honestIF: InstanceFactor;
    {72}new testUuid: UUID;
    {73}new testVerifierKey: IdentityKey;
    (
        {74}let bf_1: BootFactor = bootFactor in
        {75}let ifa_1: InstanceFactor = honestIF in
        {76}let uuid_2: UUID = testUuid in
        {77}let verifierPubKey_1: PublicKey = derivePubKey(testVerifierKey) in
        {78}let authKey_1: bitstring = deriveAuthKey(bf_1,ifa_1,uuid_2) in
        {79}let encKey_1: EncPrivateKey = deriveEncKey(bf_1,ifa_1,uuid_2) in
        {80}let encPubKey_1: EncPublicKey = deriveEncPubKey(encKey_1) in
        {81}let ihb_1: IHB = calculateIHB(bf_1,ifa_1) in
        {82}event AttesterInitiates(bf_1,ifa_1,uuid_2);
        {83}let phase1_payload_2: bitstring = (encPubKey_1,ihb_1) in
        {84}let phase1_mac_2: MAC = computeMAC(phase1_payload_2,authKey_1) in
        {85}out(public_channel, (phase1_payload_2,phase1_mac_2));
        {86}in(public_channel, (ciphertext_2: bitstring,verifier_sig_1: Signature));
        {87}let verified_ciphertext_1: bitstring = verify(ciphertext_2,verifier_sig_1,verifierPubKey_1) in
        {88}event AttesterAuthenticatesVerifier(verifierPubKey_1);
        {89}let plaintext_2: bitstring = pdec(verified_ciphertext_1,encKey_1) in
        {90}let (vf_2: ValidatorFactor,nonce_2: Nonce) = plaintext_2 in
        {91}event AttesterUsesNonce(nonce_2);
        {92}let idKey_1: IdentityKey = deriveIdKey(bf_1,vf_2,uuid_2) in
        {93}let pubKey_1: PublicKey = derivePubKey(idKey_1) in
        {94}event AttesterPresentsKey(pubKey_1);
        {95}let jp_proof_1: JP_Proof = calculateJP(bf_1,vf_2) in
        {96}let hmacKey_1: HmacKey = deriveHmacKey(bf_1,vf_2,uuid_2) in
        {97}let bound_hash_1: BoundHash = calculateBoundHash(ihb_1,pubKey_1,nonce_2) in
        {98}let pop_tag_1: PoPTag = computePoP(hmacKey_1,bound_hash_1) in
        {99}let final_eat_payload_2: bitstring = (ihb_1,jp_proof_1,nonce_2,pubKey_1,pop_tag_1) in
        {100}let final_signature_2: Signature = sign(final_eat_payload_2,idKey_1) in
        {101}out(public_channel, (final_eat_payload_2,final_signature_2,pubKey_1))
    ) | (
        {102}let expected_bf_1: BootFactor = bootFactor in
        {103}let expected_ifa_1: InstanceFactor = honestIF in
        {104}let uuid_3: UUID = testUuid in
        {105}let verifierIdKey_2: IdentityKey = testVerifierKey in
        {106}in(public_channel, (phase1_payload_3: bitstring,phase1_mac_3: MAC));
        {107}let (attester_enc_pk_1: EncPublicKey,received_ihb_1: IHB) = phase1_payload_3 in
        {108}let expected_authKey_1: bitstring = deriveAuthKey(expected_bf_1,expected_ifa_1,uuid_3) in
        {109}if verifyMAC(phase1_payload_3,phase1_mac_3,expected_authKey_1) then
        {110}let expected_ihb_1: IHB = calculateIHB(expected_bf_1,expected_ifa_1) in
        {111}if (received_ihb_1 = expected_ihb_1) then
        {112}let expected_encKey_1: EncPrivateKey = deriveEncKey(expected_bf_1,expected_ifa_1,uuid_3) in
        {113}let expected_encPubKey_1: EncPublicKey = deriveEncPubKey(expected_encKey_1) in
        {114}if (attester_enc_pk_1 = expected_encPubKey_1) then
        {115}new seed_1: VFSeed;
        {116}let vf_3: ValidatorFactor = mkVF(seed_1,expected_ifa_1) in
        {117}event VFReleased(vf_3);
        {118}new nonce_3: Nonce;
        {119}event VerifierGeneratesNonce(nonce_3);
        {120}let plaintext_3: bitstring = (vf_3,nonce_3) in
        {121}let ciphertext_3: bitstring = penc(plaintext_3,attester_enc_pk_1) in
        {122}let verifier_signature_1: Signature = sign(ciphertext_3,verifierIdKey_2) in
        {123}event VerifierAuthenticated(verifierIdKey_2);
        {124}event VerifierKeyMatch(derivePubKey(verifierIdKey_2),verifierIdKey_2);
        {125}out(public_channel, (ciphertext_3,verifier_signature_1));
        {126}in(public_channel, (final_eat_payload_3: bitstring,final_signature_3: Signature,final_pubKey_1: PublicKey));
        {127}let verified_final_1: bitstring = verify(final_eat_payload_3,final_signature_3,final_pubKey_1) in
        {128}let (rec_ihb_1: IHB,rec_jp_1: JP_Proof,rec_nonce_1: Nonce,rec_pubKey_1: PublicKey,rec_pop_1: PoPTag) = verified_final_1 in
        {129}if (rec_nonce_1 = nonce_3) then
        {130}let expected_idKey_1: IdentityKey = deriveIdKey(expected_bf_1,vf_3,uuid_3) in
        {131}let expected_pubKey_1: PublicKey = derivePubKey(expected_idKey_1) in
        {132}if (final_pubKey_1 = expected_pubKey_1) then
        {133}event VerifierValidatesWithKey(final_pubKey_1);
        {134}let expected_jp_1: JP_Proof = calculateJP(expected_bf_1,vf_3) in
        {135}if (rec_jp_1 = expected_jp_1) then
        {136}let expected_hmac_key_1: HmacKey = deriveHmacKey(expected_bf_1,vf_3,uuid_3) in
        {137}let expected_bound_hash_1: BoundHash = calculateBoundHash(rec_ihb_1,rec_pubKey_1,rec_nonce_1) in
        {138}if verifyPoP(rec_pop_1,expected_hmac_key_1,expected_bound_hash_1) then
        {139}event VerifierAccepts(expected_bf_1,expected_ifa_1,uuid_3)
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new instanceFactor: InstanceFactor;
{2}new ecaUuid: UUID;
{3}new verifierIdKey: IdentityKey;
(
    {6}let uuid: UUID = ecaUuid in
    {5}let ifa: InstanceFactor = instanceFactor in
    {4}let bf: BootFactor = bootFactor in
    {12}event AttesterInitiates(bf,ifa,uuid);
    {11}let ihb: IHB = calculateIHB(bf,ifa) in
    {9}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {10}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {13}let phase1_payload: bitstring = (encPubKey,ihb) in
    {8}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {14}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {15}out(public_channel, (phase1_payload,phase1_mac));
    {16}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {7}let verifierPubKey: PublicKey = derivePubKey(verifierIdKey) in
    {17}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,verifierPubKey) in
    {18}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {19}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {20}event AttesterUsesNonce(nonce);
    {21}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {22}let pubKey: PublicKey = derivePubKey(idKey) in
    {23}event AttesterPresentsKey(pubKey);
    {26}let bound_hash: BoundHash = calculateBoundHash(ihb,pubKey,nonce) in
    {25}let hmacKey: HmacKey = deriveHmacKey(bf,vf,uuid) in
    {27}let pop_tag: PoPTag = computePoP(hmacKey,bound_hash) in
    {24}let jp_proof: JP_Proof = calculateJP(bf,vf) in
    {28}let final_eat_payload: bitstring = (ihb,jp_proof,nonce,pubKey,pop_tag) in
    {29}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {30}out(public_channel, (final_eat_payload,final_signature,pubKey))
) | (
    {35}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {36}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {33}let uuid_1: UUID = ecaUuid in
    {32}let expected_ifa: InstanceFactor = instanceFactor in
    {31}let expected_bf: BootFactor = bootFactor in
    {37}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa,uuid_1) in
    {38}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {39}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa) in
    {40}if (received_ihb = expected_ihb) then
    {41}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa,uuid_1) in
    {42}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {43}if (attester_enc_pk = expected_encPubKey) then
    {44}new seed: VFSeed;
    {45}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa) in
    {46}event VFReleased(vf_1);
    {47}new nonce_1: Nonce;
    {48}event VerifierGeneratesNonce(nonce_1);
    {34}let verifierIdKey_1: IdentityKey = verifierIdKey in
    {52}event VerifierAuthenticated(verifierIdKey_1);
    {53}event VerifierKeyMatch(derivePubKey(verifierIdKey_1),verifierIdKey_1);
    {49}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {50}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {51}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey_1) in
    {54}out(public_channel, (ciphertext_1,verifier_signature));
    {55}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {56}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {57}let (rec_ihb: IHB,rec_jp: JP_Proof,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_pop: PoPTag) = verified_final in
    {58}if (rec_nonce = nonce_1) then
    {59}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {60}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {61}if (final_pubKey = expected_pubKey) then
    {62}event VerifierValidatesWithKey(final_pubKey);
    {63}let expected_jp: JP_Proof = calculateJP(expected_bf,vf_1) in
    {64}if (rec_jp = expected_jp) then
    {66}let expected_bound_hash: BoundHash = calculateBoundHash(rec_ihb,rec_pubKey,rec_nonce) in
    {65}let expected_hmac_key: HmacKey = deriveHmacKey(expected_bf,vf_1,uuid_1) in
    {67}if verifyPoP(rec_pop,expected_hmac_key,expected_bound_hash) then
    {68}event VerifierAccepts(expected_bf,expected_ifa,uuid_1)
) | (
    {69}new compromisedIF: InstanceFactor;
    {70}out(public_channel, compromisedIF)
) | (
    {71}new honestIF: InstanceFactor;
    {72}new testUuid: UUID;
    {73}new testVerifierKey: IdentityKey;
    (
        {76}let uuid_2: UUID = testUuid in
        {75}let ifa_1: InstanceFactor = honestIF in
        {74}let bf_1: BootFactor = bootFactor in
        {82}event AttesterInitiates(bf_1,ifa_1,uuid_2);
        {81}let ihb_1: IHB = calculateIHB(bf_1,ifa_1) in
        {79}let encKey_1: EncPrivateKey = deriveEncKey(bf_1,ifa_1,uuid_2) in
        {80}let encPubKey_1: EncPublicKey = deriveEncPubKey(encKey_1) in
        {83}let phase1_payload_2: bitstring = (encPubKey_1,ihb_1) in
        {78}let authKey_1: bitstring = deriveAuthKey(bf_1,ifa_1,uuid_2) in
        {84}let phase1_mac_2: MAC = computeMAC(phase1_payload_2,authKey_1) in
        {85}out(public_channel, (phase1_payload_2,phase1_mac_2));
        {86}in(public_channel, (ciphertext_2: bitstring,verifier_sig_1: Signature));
        {77}let verifierPubKey_1: PublicKey = derivePubKey(testVerifierKey) in
        {87}let verified_ciphertext_1: bitstring = verify(ciphertext_2,verifier_sig_1,verifierPubKey_1) in
        {88}event AttesterAuthenticatesVerifier(verifierPubKey_1);
        {89}let plaintext_2: bitstring = pdec(verified_ciphertext_1,encKey_1) in
        {90}let (vf_2: ValidatorFactor,nonce_2: Nonce) = plaintext_2 in
        {91}event AttesterUsesNonce(nonce_2);
        {92}let idKey_1: IdentityKey = deriveIdKey(bf_1,vf_2,uuid_2) in
        {93}let pubKey_1: PublicKey = derivePubKey(idKey_1) in
        {94}event AttesterPresentsKey(pubKey_1);
        {97}let bound_hash_1: BoundHash = calculateBoundHash(ihb_1,pubKey_1,nonce_2) in
        {96}let hmacKey_1: HmacKey = deriveHmacKey(bf_1,vf_2,uuid_2) in
        {98}let pop_tag_1: PoPTag = computePoP(hmacKey_1,bound_hash_1) in
        {95}let jp_proof_1: JP_Proof = calculateJP(bf_1,vf_2) in
        {99}let final_eat_payload_2: bitstring = (ihb_1,jp_proof_1,nonce_2,pubKey_1,pop_tag_1) in
        {100}let final_signature_2: Signature = sign(final_eat_payload_2,idKey_1) in
        {101}out(public_channel, (final_eat_payload_2,final_signature_2,pubKey_1))
    ) | (
        {106}in(public_channel, (phase1_payload_3: bitstring,phase1_mac_3: MAC));
        {107}let (attester_enc_pk_1: EncPublicKey,received_ihb_1: IHB) = phase1_payload_3 in
        {104}let uuid_3: UUID = testUuid in
        {103}let expected_ifa_1: InstanceFactor = honestIF in
        {102}let expected_bf_1: BootFactor = bootFactor in
        {108}let expected_authKey_1: bitstring = deriveAuthKey(expected_bf_1,expected_ifa_1,uuid_3) in
        {109}if verifyMAC(phase1_payload_3,phase1_mac_3,expected_authKey_1) then
        {110}let expected_ihb_1: IHB = calculateIHB(expected_bf_1,expected_ifa_1) in
        {111}if (received_ihb_1 = expected_ihb_1) then
        {112}let expected_encKey_1: EncPrivateKey = deriveEncKey(expected_bf_1,expected_ifa_1,uuid_3) in
        {113}let expected_encPubKey_1: EncPublicKey = deriveEncPubKey(expected_encKey_1) in
        {114}if (attester_enc_pk_1 = expected_encPubKey_1) then
        {115}new seed_1: VFSeed;
        {116}let vf_3: ValidatorFactor = mkVF(seed_1,expected_ifa_1) in
        {117}event VFReleased(vf_3);
        {118}new nonce_3: Nonce;
        {119}event VerifierGeneratesNonce(nonce_3);
        {105}let verifierIdKey_2: IdentityKey = testVerifierKey in
        {123}event VerifierAuthenticated(verifierIdKey_2);
        {124}event VerifierKeyMatch(derivePubKey(verifierIdKey_2),verifierIdKey_2);
        {120}let plaintext_3: bitstring = (vf_3,nonce_3) in
        {121}let ciphertext_3: bitstring = penc(plaintext_3,attester_enc_pk_1) in
        {122}let verifier_signature_1: Signature = sign(ciphertext_3,verifierIdKey_2) in
        {125}out(public_channel, (ciphertext_3,verifier_signature_1));
        {126}in(public_channel, (final_eat_payload_3: bitstring,final_signature_3: Signature,final_pubKey_1: PublicKey));
        {127}let verified_final_1: bitstring = verify(final_eat_payload_3,final_signature_3,final_pubKey_1) in
        {128}let (rec_ihb_1: IHB,rec_jp_1: JP_Proof,rec_nonce_1: Nonce,rec_pubKey_1: PublicKey,rec_pop_1: PoPTag) = verified_final_1 in
        {129}if (rec_nonce_1 = nonce_3) then
        {130}let expected_idKey_1: IdentityKey = deriveIdKey(expected_bf_1,vf_3,uuid_3) in
        {131}let expected_pubKey_1: PublicKey = derivePubKey(expected_idKey_1) in
        {132}if (final_pubKey_1 = expected_pubKey_1) then
        {133}event VerifierValidatesWithKey(final_pubKey_1);
        {134}let expected_jp_1: JP_Proof = calculateJP(expected_bf_1,vf_3) in
        {135}if (rec_jp_1 = expected_jp_1) then
        {137}let expected_bound_hash_1: BoundHash = calculateBoundHash(rec_ihb_1,rec_pubKey_1,rec_nonce_1) in
        {136}let expected_hmac_key_1: HmacKey = deriveHmacKey(expected_bf_1,vf_3,uuid_3) in
        {138}if verifyPoP(rec_pop_1,expected_hmac_key_1,expected_bound_hash_1) then
        {139}event VerifierAccepts(expected_bf_1,expected_ifa_1,uuid_3)
    )
)

-- Query not attacker(bootFactor[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(bootFactor[])
goal reachable: attacker(bootFactor[])

Derivation:

1. The attacker initially knows bootFactor[].
attacker(bootFactor[]).

2. By 1, attacker(bootFactor[]).
The goal is reached, represented in the following fact:
attacker(bootFactor[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

new honestIF: InstanceFactor creating honestIF_1 at {71}

new testUuid: UUID creating testUuid_1 at {72}

new testVerifierKey: IdentityKey creating testVerifierKey_1 at {73}

event AttesterInitiates(bootFactor,honestIF_1,testUuid_1) at {82}

out(public_channel, ((~M,~M_1),~M_2)) with ~M = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)), ~M_1 = calculateIHB(bootFactor,honestIF_1), ~M_2 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)),calculateIHB(bootFactor,honestIF_1)),deriveAuthKey(bootFactor,honestIF_1,testUuid_1)) at {85}

new compromisedIF: InstanceFactor creating compromisedIF_1 at {69}

out(public_channel, ~M_3) with ~M_3 = compromisedIF_1 at {70}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_4,~M_5),~M_6)) with ~M_4 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_5 = calculateIHB(bootFactor,instanceFactor_1), ~M_6 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

The attacker has the message bootFactor.
A trace has been found.
RESULT not attacker(bootFactor[]) is false.
-- Query not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(deriveIdKey(bf_2,vf_4,uuid_4))
goal reachable: attacker(bf_2) && attacker(vf_4) && attacker(uuid_4) -> attacker(deriveIdKey(bf_2,vf_4,uuid_4))

Derivation:

1. We assume as hypothesis that
attacker(uuid_4).

2. We assume as hypothesis that
attacker(vf_4).

3. We assume as hypothesis that
attacker(bf_2).

4. By 3, the attacker may know bf_2.
By 2, the attacker may know vf_4.
By 1, the attacker may know uuid_4.
Using the function deriveIdKey the attacker may obtain deriveIdKey(bf_2,vf_4,uuid_4).
attacker(deriveIdKey(bf_2,vf_4,uuid_4)).

5. By 4, attacker(deriveIdKey(bf_2,vf_4,uuid_4)).
The goal is reached, represented in the following fact:
attacker(deriveIdKey(bf_2,vf_4,uuid_4)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

new honestIF: InstanceFactor creating honestIF_1 at {71}

new testUuid: UUID creating testUuid_1 at {72}

new testVerifierKey: IdentityKey creating testVerifierKey_1 at {73}

event AttesterInitiates(bootFactor,honestIF_1,testUuid_1) at {82}

out(public_channel, ((~M,~M_1),~M_2)) with ~M = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)), ~M_1 = calculateIHB(bootFactor,honestIF_1), ~M_2 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)),calculateIHB(bootFactor,honestIF_1)),deriveAuthKey(bootFactor,honestIF_1,testUuid_1)) at {85}

new compromisedIF: InstanceFactor creating compromisedIF_1 at {69}

out(public_channel, ~M_3) with ~M_3 = compromisedIF_1 at {70}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_4,~M_5),~M_6)) with ~M_4 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_5 = calculateIHB(bootFactor,instanceFactor_1), ~M_6 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

The attacker has the message deriveIdKey(a,a_1,a_2).
A trace has been found.
RESULT not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) is false.
-- Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4))
goal reachable: b-event(@p_act(@occ86[],(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])))) && b-inj-event(AttesterInitiates(bootFactor[],honestIF[],testUuid[]),@occ82[]) -> inj-event(VerifierAccepts(bootFactor[],honestIF[],testUuid[]),@occ139_1)
The 1st, 2nd hypotheses occur strictly before the conclusion.
Abbreviations:
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
@occ139_1 = @occ139[final_pubKey_1 = derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),final_signature_3 = sign((calculateIHB(bootFactor[],honestIF[]),calculateJP(bootFactor[],mkVF(seed_2,honestIF[])),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),computePoP(deriveHmacKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[]),calculateBoundHash(calculateIHB(bootFactor[],honestIF[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),nonce_4))),deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),final_eat_payload_3 = (calculateIHB(bootFactor[],honestIF[]),calculateJP(bootFactor[],mkVF(seed_2,honestIF[])),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),computePoP(deriveHmacKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[]),calculateBoundHash(calculateIHB(bootFactor[],honestIF[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])),nonce_4))),phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
goal reachable: b-event(@p_act(@occ16[],(penc((mkVF(seed_2,instanceFactor[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),sign(penc((mkVF(seed_2,instanceFactor[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[])))) && b-inj-event(AttesterInitiates(bootFactor[],instanceFactor[],ecaUuid[]),@occ12[]) -> inj-event(VerifierAccepts(bootFactor[],instanceFactor[],ecaUuid[]),@occ68_1)
The 1st, 2nd hypotheses occur strictly before the conclusion.
Abbreviations:
seed_2 = seed[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
nonce_4 = nonce_1[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
@occ68_1 = @occ68[final_pubKey = derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),final_signature_1 = sign((calculateIHB(bootFactor[],instanceFactor[]),calculateJP(bootFactor[],mkVF(seed_2,instanceFactor[])),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),computePoP(deriveHmacKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[]),calculateBoundHash(calculateIHB(bootFactor[],instanceFactor[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),nonce_4))),deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),final_eat_payload_1 = (calculateIHB(bootFactor[],instanceFactor[]),calculateJP(bootFactor[],mkVF(seed_2,instanceFactor[])),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),computePoP(deriveHmacKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[]),calculateBoundHash(calculateIHB(bootFactor[],instanceFactor[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])),nonce_4))),phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
RESULT inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) is true.
-- Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n))
goal reachable: b-event(VerifierGeneratesNonce(nonce_4)) -> event(AttesterUsesNonce(nonce_4))
Abbreviations:
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
goal reachable: b-event(VerifierGeneratesNonce(nonce_4)) -> event(AttesterUsesNonce(nonce_4))
Abbreviations:
nonce_4 = nonce_1[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
RESULT event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.
-- Query event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk))
goal reachable: b-event(AttesterPresentsKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[])))) -> event(VerifierValidatesWithKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF[]),testUuid[]))))
Abbreviations:
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
goal reachable: b-event(AttesterPresentsKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[])))) -> event(VerifierValidatesWithKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,instanceFactor[]),ecaUuid[]))))
Abbreviations:
seed_2 = seed[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
RESULT event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk)) is true.
-- Query not (event(VFReleased(vf_4)) && attacker(vf_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(VFReleased(vf_4)) && attacker(vf_4))
RESULT not (event(VFReleased(vf_4)) && attacker(vf_4)) is true.
-- Query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk)))
goal reachable: event(AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey[]))) && event(VerifierKeyMatch(derivePubKey(testVerifierKey[]),testVerifierKey[]))

Derivation:
Abbreviations:
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))]

1. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))) may be sent to the attacker at output {85}.
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])))).

2. By 1, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))).
Using the function 2-proj-2-tuple the attacker may obtain computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])).
attacker(computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))).

3. By 1, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))).
Using the function 1-proj-2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))).

4. By 3, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])).
Using the function 2-proj-2-tuple the attacker may obtain calculateIHB(bootFactor[],honestIF[]).
attacker(calculateIHB(bootFactor[],honestIF[])).

5. By 3, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])).
Using the function 1-proj-2-tuple the attacker may obtain deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])).
attacker(deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))).

6. By 5, the attacker may know deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])).
By 4, the attacker may know calculateIHB(bootFactor[],honestIF[]).
Using the function 2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[]))).

7. By 6, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])).
By 2, the attacker may know computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])).
Using the function 2-tuple the attacker may obtain ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))).
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[])))).

8. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))) that the attacker may have by 7 may be received at input {106}.
So event VerifierKeyMatch(derivePubKey(testVerifierKey[]),testVerifierKey[]) may be executed at {124}.
event(VerifierKeyMatch(derivePubKey(testVerifierKey[]),testVerifierKey[])).

9. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])),calculateIHB(bootFactor[],honestIF[])),deriveAuthKey(bootFactor[],honestIF[],testUuid[]))) that the attacker may have by 7 may be received at input {106}.
So the message (penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])) may be sent to the attacker at output {125}.
attacker((penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[]))).

10. By 9, the attacker may know (penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])).
Using the function 2-proj-2-tuple the attacker may obtain sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[]).
attacker(sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])).

11. By 9, the attacker may know (penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])).
Using the function 1-proj-2-tuple the attacker may obtain penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))).
attacker(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[])))).

12. By 11, the attacker may know penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))).
By 10, the attacker may know sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[]).
Using the function 2-tuple the attacker may obtain (penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])).
attacker((penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[]))).

13. The message (penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),sign(penc((mkVF(seed_2,honestIF[]),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF[],testUuid[]))),testVerifierKey[])) that the attacker may have by 12 may be received at input {86}.
So event AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey[])) may be executed at {88}.
event(AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey[]))).

14. By 13, event(AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey[]))).
By 8, event(VerifierKeyMatch(derivePubKey(testVerifierKey[]),testVerifierKey[])).
The goals are reached, combined in the following fact:
event(AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey[]))) && event(VerifierKeyMatch(derivePubKey(testVerifierKey[]),testVerifierKey[])).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

new honestIF: InstanceFactor creating honestIF_1 at {71}

new testUuid: UUID creating testUuid_1 at {72}

new testVerifierKey: IdentityKey creating testVerifierKey_1 at {73}

event AttesterInitiates(bootFactor,honestIF_1,testUuid_1) at {82}

out(public_channel, ((~M,~M_1),~M_2)) with ~M = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)), ~M_1 = calculateIHB(bootFactor,honestIF_1), ~M_2 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)),calculateIHB(bootFactor,honestIF_1)),deriveAuthKey(bootFactor,honestIF_1,testUuid_1)) at {85}

new compromisedIF: InstanceFactor creating compromisedIF_1 at {69}

out(public_channel, ~M_3) with ~M_3 = compromisedIF_1 at {70}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_4,~M_5),~M_6)) with ~M_4 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_5 = calculateIHB(bootFactor,instanceFactor_1), ~M_6 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

in(public_channel, ((~M,~M_1),~M_2)) with ~M = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)), ~M_1 = calculateIHB(bootFactor,honestIF_1), ~M_2 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1)),calculateIHB(bootFactor,honestIF_1)),deriveAuthKey(bootFactor,honestIF_1,testUuid_1)) at {106}

new seed_1: VFSeed creating seed_3 at {115}

event VFReleased(mkVF(seed_3,honestIF_1)) at {117}

new nonce_3: Nonce creating nonce_5 at {118}

event VerifierGeneratesNonce(nonce_5) at {119}

event VerifierAuthenticated(testVerifierKey_1) at {123}

event VerifierKeyMatch(derivePubKey(testVerifierKey_1),testVerifierKey_1) at {124} (goal)

out(public_channel, (~M_7,~M_8)) with ~M_7 = penc((mkVF(seed_3,honestIF_1),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1))), ~M_8 = sign(penc((mkVF(seed_3,honestIF_1),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1))),testVerifierKey_1) at {125}

in(public_channel, (~M_7,~M_8)) with ~M_7 = penc((mkVF(seed_3,honestIF_1),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1))), ~M_8 = sign(penc((mkVF(seed_3,honestIF_1),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_1,testUuid_1))),testVerifierKey_1) at {86}

event AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey_1)) at {88} (goal)

The event AttesterAuthenticatesVerifier(derivePubKey(testVerifierKey_1)) is executed at {88}.
The event VerifierKeyMatch(derivePubKey(testVerifierKey_1),testVerifierKey_1) is executed at {124}.
A trace has been found.
RESULT not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) is false.

--------------------------------------------------------------
Verification summary:

Query not attacker(bootFactor[]) is false.

Query not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) is false.

Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) is true.

Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.

Query event(VerifierValidatesWithKey(pk)) ==> event(AttesterPresentsKey(pk)) is true.

Query not (event(VFReleased(vf_4)) && attacker(vf_4)) is true.

Query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) is false.

--------------------------------------------------------------

